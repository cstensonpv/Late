<!DOCTYPE html>
<meta charset="utf-8">
<title>PivotGraph (Rollup) Layout</title>
<style>

  body {
  font-family: sans-serif;
  font-size: 10px;
  }

  .link {
  fill: none;
  stroke: #000;
  stroke-opacity: .25;
  }

  .busyline{
  fill:red;
  stroke: #DB2525;
  stroke-opacity: .5;
  }

  .node {
  fill: #fff;
  stroke: steelblue;
  }

  .axis path,
  .axis line {
  display: none;
  }

</style>
<body>
<!-- <div><button id="rotebro" type="button" onclick="updateCircle(this.id)">Click Me!</button></div> -->
<script src="lib/d3.min.js"></script>
<script src="lib/rollup.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script>

var margin = {top: 90, right: 240, bottom: 90, left: 240},
    width = 960 - margin.left - margin.right,
    t = .5,
    height = 1000 - margin.top - margin.bottom;

var currentPosStations = {};

function fx(d) { return d.x; }
function fy(d) { return d.y; }

var x = d3.scale.ordinal()
    .rangePoints([256, width - 6]);

var y = d3.scale.ordinal()
    .rangePoints([6, height - 6]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("top");

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

var rollup = d3.rollup()
    .x(function(d) { return x(fx(d)); })
    .y(function(d) { return y(fy(d)); });

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


var data = null;
d3.json("data/pendeltag.json", function(error, social) {
  if (error) throw error;
  currentPosStations = social.nodes;
  x.domain(social.nodes.map(fx));
  y.domain(social.nodes.map(fy));
  var graph = rollup(social);
  data = graph;
  //Append the links between circles
  svg.selectAll(".link")
      .data(graph.links)
    .enter().append("path")
      .attr("class", "link")
      .attr("id", function(d,i) {return i;})
      .attr("d", function(d,i) {
        var startX = d.source.x.toFixed(0),
            startY = d.source.y.toFixed(0),
            stopX = d.target.x.toFixed(0);
            stopY = d.target.y.toFixed(0);
        return "M "+startX+" "+startY + " "+stopX+" "+stopY;
      })
      .style("stroke-width", function(d) { return d.value * 4; });

  var busyLine = svg.append("path")
      .attr("id","busyLine")
      .attr("class","busyline");

  // Append nodes (circles)
  var stations = svg.selectAll(".station")
      .data(graph.nodes)
      .enter()
      .append("g")
      .attr("id",function(d,i){
        return "station_" + d.nodes[0].id;
      })
      .classed("station", true);

var station = stations.append("circle")
      .attr("class", "node")
      .attr("r", function(d) { return 8;/*Math.sqrt(d.nodes.length * 40);*/ })
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });


var label = stations.append("text")
      .attr("class", "word")
      .attr("dy", function(d) {return d.y })
      .attr("dx", function(d) {return d.x + 10 })
      .text( function(d) {
        return d.nodes[0].name;
      })

  svg.append("g")
      .attr("class", "x axis");

  svg.append("g")
      .attr("class", "y axis");

});


var nrcalls = 0;
ajaxCall();
window.setInterval(function(){
  ajaxCall();
  nrcalls++;
  console.log(nrcalls);
}, 4000);






function ajaxCall(){
$.ajax({
  url: "http://localhost:3000/delaydata/",
  dataType: "jsonp",
  success: function(result){
    console.log("Did ajax call");
    for(res in result){
      var stationId = result[res].siteid;
      var count = 0;

      //to get stations that are not Stockholm C or Marsta
      if(result[res].siteid != 9500 && result[res].siteid != 9000){
        //console.log(result[res].siteid);
        var str = "" + result[res].siteid;
        var isNorthMoving = null;//is the delay to the north or to the south.
        if(result[count].delayNorth > result[count].delaySouth)
          isNorthMoving = true;
        else
          isNorthMoving = false;
        //second parameter is about scaling the movement. Absolute value of the delay between north and
        //the south.
        
        updateCircle(str,result[res].delayNorth,isNorthMoving);

      }
      
    }


      

    },
    error:function(jqXHR,status,error){
      if (jqXHR.status === 0) {
          console.log('Not connect.\n Verify Network.');
      } else if (jqXHR.status == 404) {
          console.log('Requested page not found. [404]');
      } else if (jqXHR.status == 500) {
          console.log('Internal Server Error [500].');
      } else if (exception === 'parsererror') {
          console.log('Requested JSON parse failed.');
      } else if (exception === 'timeout') {
          console.log('Time out error.');
      } else if (exception === 'abort') {
          console.log('Ajax request aborted.');
      } else {
          console.log('Uncaught Error.\n' + jqXHR.responseText);
      }
    }
  });
}


function updateCircle(clicked_id,delayTime,isMovingNorth)
{
  var last = 0;
  //console.log(delayTime);
  //console.log(clicked_id);
  d3.timer(function(elapsed) {
    t = (t + (elapsed - last) / 5000) % 1;
    last = elapsed;
    var factor = last/100;

    if(factor < 20){//temporary measurement.
      update(delayTime/60000,clicked_id,isMovingNorth);//redraw the selected circle and the path
    }
  });

}


function update(delay,selected,isMovingNorth) {

  var slct = "#station_" + selected;
  delay = delay * 2; //to see it better
  //console.log("Updates "+ selected);
  /*
  d3.select(".stations").remove();
  var stations = svg.selectAll(".station")
    .data(data.nodes)
    .enter()
    .append("g")
    .attr("id",function(d,i){
      return "station_" + d.nodes[0].id;
    })
    .classed("station", true);
*/
  var currentIndex = getStationIndex(selected);
  var station = svg.select(slct);

  var xCircle,yCircle = 0;

  if(!isMovingNorth)//change direction of the circle moving
    x *= -1;

  station.select("circle")
    .attr("class", "node")
    .attr("r", function(d) { return 8; })
    .attr("cx", function(d,i) { xCircle = d.x; return d.x; })
    .attr("cy", function(d,i) { currentPosStations[currentIndex]["y"] = (d.y - delay); yCircle = d.y; return d.y - delay; });

   /*station.select("#poly")
    .attr("points",generatePolygonPoints(50,50,xCircle,yCircle));*/

  var label = station.select("text")
    .attr("class", "word")
    .attr("dy", function(d) {return d.y - delay})
    .attr("dx", function(d) {return d.x + 10})
    .text( function(d) {
    return d.nodes[0].name + " : " + d.nodes[0].id +" northDelay: "+delay.toFixed(1) +"min";
  });

  var currentStation = getStation(selected);

  //Gets the corresponding patrhs through id
  var northLink = $("#"+currentStation.north);
  var southLink = $("#"+currentStation.south);
  //console.log(southLink[0].__data__);

    //console.log("delay: "+delay);
    if(delay > 0){
      southLink.attr("style","stroke-width: 8; stroke: red;");
    }else{
      southLink.attr("style","stroke-width: 4;");
    }
    // should be using the currentPosition of DÂ´Sattions tio draw instead of the __data__.source etc
    southLink.attr("d", function(){return calcPath(southLink[0].__data__.source, southLink[0].__data__.target,delay, "north")})

    northLink.attr("d", function(){return calcPath(northLink[0].__data__.source, northLink[0].__data__.target,delay, "south")})

}
function getStation(selected){
  for(station in data.nodes){
    if(data.nodes[station].nodes[0].id == selected){
      return data.nodes[station].nodes[0];
    }
  }
  return "";
}
function getStationIndex(selected){
  for(station in data.nodes){
    if(data.nodes[station].nodes[0].id == selected){
      return station;
    }
  }
  return "";
}


function calcPath(source,target,x,dir) {
  //console.log(source);
  var startX = source.x.toFixed(0),
    startY = parseInt(source.y.toFixed(0)),
    stopX = target.x.toFixed(0);
    stopY = parseInt(target.y.toFixed(0));

    if(dir === "north"){
      stopY -= x;
      //console.log("stopY: "+stopY);
    }else if(dir === "south"){
      startY -= x;
      //console.log("StartY :"+startY);
    }
  return "M "+startX+" "+startY + " "+stopX+" "+stopY;
}
</script>