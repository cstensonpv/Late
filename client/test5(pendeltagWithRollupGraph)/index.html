<!DOCTYPE html>
<meta charset="utf-8">
<title>PivotGraph (Rollup) Layout</title>
<link rel="stylesheet" href="css/d3.slider.css"/>
<link rel="stylesheet" href="css/arcstyle.css"/>
<style>

  body {
  font-family: sans-serif;
  font-size: 10px;
  }

  .link {
  fill: none;
  stroke: #000;
  stroke-opacity: .25;
  }

  .busyline{
  fill:red;
  stroke: #DB2525;
  stroke-opacity: .5;
  }

  .node {
  fill: #fff;
  stroke: steelblue;
  }

  .axis path,
  .axis line {
  display: none;
  }

</style>
<body>
<div>
  <div><h2>Slider with slide event: <span id="slider3text">0</span></h2></div>
  <div id="startButton"><button type="button" onclick="startAnimate()">Start</button></div>
  <div id="rewindButton"><button type="button" onclick="rewind()">Rewind</button></div>
  <div id="stopButton"><button type="button" onclick="stop()">Stop</button></div>
</div>
<div id="slider6"></div>


<!-- <div><button id="rotebro" type="button" onclick="startTransition(this.id)">Click Me!</button></div> -->
<script src="lib/drawArc.js"></script>
<script src="lib/d3.min.js"></script>
<script src="lib/rollup.js"></script>
<script type="text/javascript" src="lib/d3.slider.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script>
var parseDate = d3.time.format("%Y-%m-%dT%H:%M:%S").parse;

var timer_ret_val = false;
var continueTimerVal = false;
var isContinue = false;
var timerCurrentValue = 0;
var last = 0;

var maxScaleofSlider = 1400

var slider = d3.slider().on("slide", function(event, value) {
    animationUpdate(value,true);
}).axis(true).min(0).max(24);

var sliderPlace = d3.select('#slider6').call(slider);

var sliderHandle = d3.select("#handle-one");
var margin = {top: 90, right: 240, bottom: 90, left: 240},
    width = 960 - margin.left - margin.right,
    t = .5,
    height = 1000 - margin.top - margin.bottom;

var currentPosStations = {};

function fx(d) {
  if(typeof data === 'number'){
    return d.x;
  }else{
    return parseInt(d.x);
  }
}

function fy(d) {
  if(typeof data === 'number'){
    return d.y;
  }else{
    return parseInt(d.y);
  }
}

var x = d3.scale.linear();

var y = d3.scale.linear();

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("top")
    .ticks(20);

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

/*var rollup = d3.rollup()
    .x(function(d) { return x(fx(d)); })
    .y(function(d) { return y(fy(d)); });*/

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .attr("id","outerSvg")
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


var data = null;
d3.json("data/pendeltag.json", function(error, social) {
  if (error) throw error;

  x.domain([getMinOfArray(social.nodes.map(fx)),getMaxOfArray(social.nodes.map(fx))])
  x.range([0, width]);
  y.domain([getMaxOfArray(social.nodes.map(fy)),getMinOfArray(social.nodes.map(fy))]);
  y.range([0,height]);

  //Append the links between circles
  svg.selectAll(".link")
      .data(social.links)
    .enter().append("path")
      .attr("class", "link")
      .attr("id", function(d,i) {return "path_"+social.nodes[d.source].id+"_"+social.nodes[d.target].id;})
      .attr("d", function(d,i) {
        var source = social.nodes[d.source];
        var target = social.nodes[d.target];
        var startX = x(parseFloat(source.x).toFixed(0)),
          startY = y(parseFloat(source.y).toFixed(0)),
          stopX = x(parseFloat(target.x).toFixed(0));
          stopY = y(parseFloat(target.y).toFixed(0));
        return "M "+startX+" "+startY + " "+stopX+" "+stopY;
      })
      .style("stroke-width", function(d) { return 4; });

  var busyLine = svg.append("path")
      .attr("id","busyLine")
      .attr("class","busyline");

  // Append nodes (circles)
  var stations = svg.selectAll(".station")
      .data(social.nodes)
      .enter()
      .append("g")
      .attr("id",function(d,i){

        return "station_" + d.id;
      })
      .classed("station", true);


/*
  To get the map back to the way it was, un-comment
    "station" and "label" variables and comment out the
    for loop with "stationNode" in it.
*/
/*var station = stations.append("circle")
      .attr("class", "node")
      .attr("r", function(d) { return 8; })
      .attr("cx", function(d) { return x(fx(d)); })
      .attr("cy", function(d) { return y(fy(d)); });*/


  var label = stations.append("text")
    .attr("class", "word")
    .attr("dy", function(d) {return 5 })
    .attr("dx", function(d) {return 10 })
    .attr("id", function(d) {return "text"+d.id })
    .text( function(d) {
      return d.name;
    });

//stationNode("#station_9501",480,60.740740740,"asd");

  /*
    This part adds the interactive circles to the "map". First parameter is the
    id of the station. Second paramter is the "cy" parameter.
    Third parameter is the name of the station
  */
  for(var i = 0; i < social.nodes.length; i++)
  {
    /*console.log(x(social.nodes[i].x));
    console.log(y(social.nodes[i].y));
    console.log("#station_"+social.nodes[i].id);*/
    var one = x(social.nodes[i].x);
    var two = y(social.nodes[i].y);
    stationNode("#station_"+social.nodes[i].id, x(social.nodes[i].x) , y(social.nodes[i].y), social.nodes[i].name);
  }


  svg.append("g")
      .attr("class", "x axis");

  svg.append("g")
      .attr("class", "y axis");

});

function getMaxOfArray(numArray) {
  return Math.max.apply(null, numArray);
}
function getMinOfArray(numArray) {
  return Math.min.apply(null, numArray);
}


function getData(minutes){
  $.ajax({
    url: "http://localhost:3000/datafromtime/"+minutes,
    dataType: "jsonp",
    success: function(result){
      //console.log(result);
      update(result);
  },
  error:function(jqXHR,status,error){
        if (jqXHR.status === 0) {
            console.log('Not connect.\n Verify Network.');
        } else if (jqXHR.status == 404) {
            console.log('Requested page not found. [404]');
        } else if (jqXHR.status == 500) {
            console.log('Internal Server Error [500].');
        } else if (exception === 'parsererror') {
            console.log('Requested JSON parse failed.');
        } else if (exception === 'timeout') {
            console.log('Time out error.');
        } else if (exception === 'abort') {
            console.log('Ajax request aborted.');
        } else {
            console.log('Uncaught Error.\n' + jqXHR.responseText);
        }
  }});
}

startTransition(9504,122000,false,213);
/*startTransition(9503,122000,true);
startTransition(9508,122000,false);
startTransition(9509,122000,true);
startTransition(9501,122000,false);*/

function stop(){
  timer_ret_val = true;
  continueTimerVal = true;
  last = timerCurrentValue;
  last *= 100;
  //console.log("push stop: "  + timerCurrentValue);
}

function startAnimate(){
  timer_ret_val = false;
  isContinue = true;
  //console.log("last:" + last);
  var cntVal = parseFloat(d3.select("#path_9502_9511").attr("T"));
  startTransition(9504,122000,false,cntVal);
  //console.log("push start: "  + timerCurrentValue);
}

function rewind()
{
  //var cntVal = d3.select("#path_9").attr("T");
}

function transitionFunction(value){

}

function percentageToMinutes(percentage){
  return percentage*14.4;
}

function minutesToPercentage(minutes){
  return minutes/14.4;
}

function animationUpdate(value,isDragged){

  var calculatedTimeValue = 0;

  if(!isDragged)
    calculatedTimeValue = percentageToMinutes(value);
  else{
    calculatedTimeValue = value*60;
    console.log("in else " + calculatedTimeValue);
  }

  d3.select('#slider3text').text(calculatedTimeValue);//*60);

  getData(calculatedTimeValue.toFixed(0));

  //console.log("value: " + value);
  var selectPath = d3.select("#path_9502_9511");
  selectPath.attr("T",calculatedTimeValue);
  var strokeStr = "rgba(255,0,0," + (value/100) + ")";

  var tmp = 0.25 + (value/100);
  selectPath
    .transition()
    .duration(0)
    .style("stroke","rgb(255,0,0)")
    .style("stroke-opacity","."+tmp)
    .attr("T",calculatedTimeValue);

  var selectPath2 = d3.select("#path_9502_9501");
  selectPath2.attr("T",calculatedTimeValue);
  if(value >= 50)
  {
    var tmp2 = 0.25 + (value-50)/100;
    selectPath2
      .transition()
      .delay(0)
      .duration(0)
      .style("stroke","rgb(255,0,0)")
      .style("stroke-opacity","."+tmp2)
      .attr("T",calculatedTimeValue);
  }
}
var currentPositionOfSlider = 0;

function update(data){
  for(var key in data)
  {
    //console.log(data[key]);
    if(typeof data[key].north === 'object')
    {
      var timeTabledDate = parseDate(data[key].north.TimeTabledDateTime);
      var expectedDate = parseDate(data[key].north.ExpectedDateTime);
      var pendeltagDelay = Math.abs(timeTabledDate - expectedDate)/60000;
      if(pendeltagDelay != 0)
      {
        var id = key.substring(3);
        d3.select("#station_"+id).style("fill","rgb(162,26,"+pendeltagDelay*10 + ")");
        console.log(pendeltagDelay + " *---* " + id);
      }
      else
      {
        d3.select("#station_"+id).style("fill","rgb(26,115,0)");
      }
    }
  }
}

function startTransition(clicked_id,delayTime,isMovingNorth,timerCur)
{
  currentPositionOfSlider = timerCur;//value of T tag
  if(!isContinue)
    d3.timer(timerTick);
  else
    d3.timer(continueTimer);
}

function continueTimer(elapsed)
{
  var normalTime = minutesToPercentage(currentPositionOfSlider);
  var x = elapsed/maxScaleofSlider;
  var actualSliderPercentage = parseFloat(normalTime) + parseFloat(x);

  console.log(elapsed + " ----- " + normalTime + " ----- " + x + " ------ " + actualSliderPercentage);

  sliderHandle.transition().duration(0).style("left",actualSliderPercentage+"%");
  animationUpdate(actualSliderPercentage,false);
  timerCurrentValue = actualSliderPercentage;

  return timer_ret_val;
}

function timerTick(elapsed)
{
  var normalTime = elapsed/maxScaleofSlider;
  //console.log(timerCurrentValue);

  //d3.select('#slider3text').text("");
  sliderHandle.transition().duration(0).style("left",normalTime+"%");
  animationUpdate(normalTime,false);
  timerCurrentValue = normalTime;

  return timer_ret_val;
}

/*function timerTick(elapsed,clicked_id,isMovingNorth,isPaused){
    console.log("elapsed: " + timerCurrentValue);

    if(!timer_ret_val)
    {
      console.log("I pushed continue: " + timerCurrentValue);
      t = (t + (timerCurrentValue - last) / 5000) % 1;
    }
    else{
      console.log("I did not pushed shit: " + timerCurrentValue);
      t = (t + (elapsed - last) / 5000) % 1;
    }
    last = elapsed;

    var factor = last/100;

    if(factor < 20){//temporary measurement.
      update(last/100,clicked_id,isMovingNorth);//redraw the selected circle and the path
    }

    var tmpVar = last/100;

    if(tmpVar <= 100)
    {
      sliderHandle.transition().duration(0).style("left",timerCurrentValue+"%");
      animationUpdate(tmpVar);
      timerCurrentValue = tmpVar;
    }
    else{
      //console.log("yarrak:" + tmpVar);
    }

    return timer_ret_val;
}*/

function getStation(selected){
  for(station in data.nodes){
    if(data.nodes[station].nodes[0].id == selected){
      return data.nodes[station].nodes[0];
    }
  }
  return "";
}

function getStationIndex(selected){
  for(station in data.nodes){
    if(data.nodes[station].nodes[0].id == selected){
      return station;
    }
  }
  return "";
}

function calcPath(source,target,x,dir) {
  var startX = source.x.toFixed(0),
    startY = parseInt(source.y.toFixed(0)),
    stopX = target.x.toFixed(0);
    stopY = parseInt(target.y.toFixed(0));

    if(dir === "north"){
      stopY += x;
    }else if(dir === "south"){
      startY += x;
    }
  return "M "+startX+" "+startY + " "+stopX+" "+stopY;
}
</script>