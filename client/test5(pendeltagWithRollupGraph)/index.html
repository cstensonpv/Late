<!DOCTYPE html>
<meta charset="utf-8">
<title>PivotGraph (Rollup) Layout</title>
<style>

  body {
  font-family: sans-serif;
  font-size: 10px;
  }

  .link {
  fill: none;
  stroke: #000;
  stroke-opacity: .25;
  }

  .busyline{
  fill:red;
  stroke: #DB2525;
  stroke-opacity: .5;
  }

  .node {
  fill: #fff;
  stroke: steelblue;
  }

  .axis path,
  .axis line {
  display: none;
  }

</style>
<body>
<!-- <div><button id="rotebro" type="button" onclick="updateCircle(this.id)">Click Me!</button></div> -->
<script src="lib/d3.min.js"></script>
<script src="lib/rollup.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script>

var margin = {top: 90, right: 240, bottom: 90, left: 240},
    width = 960 - margin.left - margin.right,
    t = .5,
    height = 1000 - margin.top - margin.bottom;

function fx(d) { return d.x; }
function fy(d) { return d.y; }

var x = d3.scale.ordinal()
    .rangePoints([256, width - 6]);

var y = d3.scale.ordinal()
    .rangePoints([6, height - 6]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("top");

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

var rollup = d3.rollup()
    .x(function(d) { return x(fx(d)); })
    .y(function(d) { return y(fy(d)); });

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


var data = null;
d3.json("data/pendeltag.json", function(error, social) {
  if (error) throw error;

  x.domain(social.nodes.map(fx));
  y.domain(social.nodes.map(fy));
  var graph = rollup(social);
  data = graph;

  //Append the links between circles
  svg.selectAll(".link")
      .data(graph.links)
    .enter().append("path")
      .attr("class", "link")
      .attr("d", function(d,i) {
        var startX = d.source.x.toFixed(0),
            startY = d.source.y.toFixed(0),
            stopX = d.target.x.toFixed(0);
            stopY = d.target.y.toFixed(0);
        return "M "+startX+" "+startY + " "+stopX+" "+stopY;
      })
      .style("stroke-width", function(d) { return d.value * 4; });

  var busyLine = svg.append("path")
      .attr("id","busyLine")
      .attr("class","busyline");

  // Append nodes (circles)
  var stations = svg.selectAll(".station")
      .data(graph.nodes)
      .enter()
      .append("g")
      .attr("id",function(d,i){
        return "station_" + d.nodes[0].id;
      })
      .classed("station", true);

/*var paths = stations.selectAll(".station")
      .data(graph.links)
      .enter()
      .append("path")
      .attr("class", "link")
      .attr("d", function(d,i) {
        console.log(d);
        var startX = d.source.x.toFixed(0),
        startY = d.source.y.toFixed(0),
        stopX = d.target.x.toFixed(0);
        stopY = d.target.y.toFixed(0);
        //console.log("M "+startX+" "+startY + " "+stopX+" "+stopY);
        console.log("M "+startX+" "+startY + " "+stopX+" "+stopY);
        return "M "+startX+" "+startY + " "+stopX+" "+stopY;
       })
      .style("stroke-width", function(d) { return d.value * 4; });*/

var station = stations.append("circle")
      .attr("class", "node")
      .attr("r", function(d) { return 8;/*Math.sqrt(d.nodes.length * 40);*/ })
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });

var shape = stations.append("polygon")
      .attr("id","poly")
      .attr("fill","red")
      .attr("points",generatePolygonPoints(0,0));

var label = stations.append("text")
      .attr("class", "word")
      .attr("dy", function(d) {return d.y })
      .attr("dx", function(d) {return d.x + 10 })
      .text( function(d) {
        return d.nodes[0].name;
      })

  svg.append("g")
      .attr("class", "x axis");

  svg.append("g")
      .attr("class", "y axis");

});


$.ajax({
  url: "http://localhost:3000/delaydata/",
  dataType: "jsonp",
  success: function(result){

      var stationId = result[0].siteid;
      var count = 0;
      //to get stations that are not Stockholm C or Marsta
      while(result[count].siteid == 9500 || result[count].siteid == 9000)
      {
        count++;
      }
      var str = "" + result[count].siteid;

      var isNorthMoving = null;//is the delay to the north or to the south.

      if(result[count].delayNorth > result[count].delaySouth)
        isNorthMoving = true;
      else
        isNorthMoving = false;
      //second parameter is about scaling the movement. Absolute value of the delay between north and
      //the south.
      updateCircle(str,Math.abs(result[count].delayNorth-result[count].delaySouth),isNorthMoving);
},
error:function(jqXHR,status,error){
      if (jqXHR.status === 0) {
          console.log('Not connect.\n Verify Network.');
      } else if (jqXHR.status == 404) {
          console.log('Requested page not found. [404]');
      } else if (jqXHR.status == 500) {
          console.log('Internal Server Error [500].');
      } else if (exception === 'parsererror') {
          console.log('Requested JSON parse failed.');
      } else if (exception === 'timeout') {
          console.log('Time out error.');
      } else if (exception === 'abort') {
          console.log('Ajax request aborted.');
      } else {
          console.log('Uncaught Error.\n' + jqXHR.responseText);
      }
}});

function updateCircle(clicked_id,delayTime,isMovingNorth)
{
  var last = 0;
  console.log(delayTime);
  d3.timer(function(elapsed) {
    t = (t + (elapsed - last) / 5000) % 1;
    last = elapsed;
    var factor = last/100;

    if(factor < 20){//temporary measurement.
      update(last/100,clicked_id,isMovingNorth);//redraw the selected circle and the path
    }
  });

}

function generatePolygonPoints(length, width,x,y){
  var points = "";
  //top
  points +=y+width/2 +",0 ";

  length = length+width/2;
  //left
  points +=y+width/10+","+length*0.4+" ";
  points +=y+","+length*0.7+" ";
  points +=y+width/10+ ","+length*0.8+" ";
  points +=y+width/5+ ","+length*0.9+" ";
  //bottom
  points +=x+width/2 +","+length+" ";
  //right
  points +=x+width - width/5+ ","+length*0.9+" ";
  points +=x+width-width/10+","+length*0.8+" ";
  points +=x+width+","+length*0.7+" ";
  points +=x+width - width/10+","+length*0.4+" ";
  //console.log(points);

  return points;
}

function update(x,selected,isMovingNorth) {

  var slct = "#station_" + selected;

  d3.select(".stations").remove();
  var stations = svg.selectAll(".station")
    .data(data.nodes)
    .enter()
    .append("g")
    .attr("id",function(d,i){
      return "station_" + d.nodes[0].id;
    })
    .classed("station", true);

  var station = svg.select(slct);

  var xCircle,yCircle = 0;

  if(!isMovingNorth)//change direction of the circle moving
    x *= -1;

  station.select("circle")
    .attr("class", "node")
    .attr("r", function(d) { return 8; })
    .attr("cx", function(d) { xCircle = d.x;return d.x; })
    .attr("cy", function(d) { yCircle = d.y;return d.y+x; });

   /*station.select("#poly")
    .attr("points",generatePolygonPoints(50,50,xCircle,yCircle));*/

  var label = station.select("text")
    .attr("class", "word")
    .attr("dy", function(d) {return d.y+x})
    .attr("dx", function(d) {return d.x + 10})
    .text( function(d) {
    return d.nodes[0].name;
  });
  //console.log(xCircle + " ------ " + yCircle);
  //M 474 168 256 6
  //M 474
  //"M "+startX+" "+startY + " "+stopX+" "+stopY;
 /* var busyLine = svg.select("#busyLine")
    .attr("d",function(d){
      var stopx = xCircle + x;
      var stopy = yCircle + x;

      var str = "M " + xCircle + " " + yCircle + " " + stopy + " " + stopx;
      return str;
    });*/
}
</script>